<!DOCTYPE html>
<html>

<body>
    <script type="text/javascript" src="hashtable.js"></script>
    <script>
    var lowest_ask_id;
    var highest_bid_id;
    var ask_orderbook = {};
    var bid_orderbook = {};
    var orders = {};

    var smartMeterToUser = {};

    var colleteral = {};



    function submitBidOrder(_maxprice, _volume) { // bid orders without _maxprice stated are simply orders with a very high _maxprice. 
        save_order("BID", _volume, _maxprice);
    }

    function submitAskOrder(_price, _volume) {
        save_order("ASK", _volume, _price);
    }


    function submitReserveAsk(_price, _volume) { // wird im selben ask order book gespeichert, da  jenes beim matching geleert wird
        save_order("ASK", _volume, _price);
    }


    var order_id = 100;
    var sm_address = 10;
    var owner_address = 0;


    function save_order(_typ, _volume, _price) {
        var Pointer = {
            id: undefined,
            next_id: undefined
        };

        var Order = {
            typ: undefined,
            volume: undefined,
            price: undefined,
            id: undefined,
            owner: undefined,
        };

        owner_address++;
        order_id++;
        sm_address++;

        colleteral[owner_address] = 100000;
        smartMeterToUser[sm_address] = owner_address;

        if (order_id in orders) return;
        orders[order_id] = Order;
        orders[order_id].typ = _typ;
        orders[order_id].volume = _volume;
        orders[order_id].price = _price;
        orders[order_id].id = order_id;
        orders[order_id].owner = owner_address;
        var positionFound = false;
        var id_iter;

        if (_typ == "ASK") {
            ask_orderbook[order_id] = Pointer;
            ask_orderbook[order_id].id = order_id; // oder_id kann schon gesetzt werden und next_id muss im folgenden bestimmt werden
            if (orders[lowest_ask_id] == undefined) { // Fall 1: es sind noch keine orders vorhanden
                lowest_ask_id = order_id;
            } else if (_price < orders[lowest_ask_id].price) { // Fall 2: order wird vorne dran gehangen
                ask_orderbook[order_id].next_id = lowest_ask_id;
                lowest_ask_id = order_id;
            } else { // Fall 3: aorder wird zwischendrin platziert
                id_iter = lowest_ask_id;
                while (!positionFound) {
                    if (ask_orderbook[id_iter].next_id == undefined) { // Fall 4: order wird ganz hinten dran gehangen
                        ask_orderbook[id_iter].next_id = order_id;
                        positionFound = true;
                    }
                    if (_price < orders[ask_orderbook[id_iter].next_id].price) {
                        ask_orderbook[order_id].next_id = ask_orderbook[id_iter].next_id;
                        ask_orderbook[id_iter].next_id = order_id;
                        positionFound = true;
                    }
                    id_iter = ask_orderbook[id_iter].next_id;
                }
            }
        }

        if (_typ == "BID") {
            bid_orderbook[order_id] = Pointer;
            bid_orderbook[order_id].id = order_id; // oder_id kann schon gesetzt werden und next_id muss im folgenden bestimmt werden
            if (orders[highest_bid_id] == undefined) { // Fall 1: es sind noch keine orders vorhanden
                highest_bid_id = order_id;
            } else if (_price > orders[highest_bid_id].price) { // Fall 2: order wird vorne dran gehangen
                bid_orderbook[order_id].next_id = highest_bid_id;
                highest_bid_id = order_id;
            } else {
                id_iter = highest_bid_id;
                while (!positionFound) {
                    if (bid_orderbook[id_iter].next_id == undefined) { // Fall 3: order wird ganz hinten dran gehangen
                        bid_orderbook[id_iter].next_id = order_id;
                        positionFound = true;
                    }
                    if (_price > orders[bid_orderbook[id_iter].next_id].price) { // Fall 4: order zwischendrin platzieren
                        bid_orderbook[order_id].next_id = bid_orderbook[id_iter].next_id;
                        bid_orderbook[id_iter].next_id = order_id;
                        positionFound = true;
                    }
                    id_iter = bid_orderbook[id_iter].next_id;
                }
            }
        }
    }
    /*
            Returns ordered list of bid orders
            author: Magnus
            */


    function getBidOrders() {
        var id_iter_bid = highest_bid_id;
        console.log("###### Bid Orders ######");
        while (orders[id_iter_bid] != undefined) {
            console.log("Price: " + orders[id_iter_bid].price + " | Volume: " + orders[id_iter_bid].volume + " | Owner: " + orders[id_iter_bid].owner);
            id_iter_bid = bid_orderbook[id_iter_bid].next_id;
        }
    }


    function getAskOrders() {
        var id_iter_ask = lowest_ask_id;
        console.log("###### Ask Orders ######");
        while (orders[id_iter_ask] != undefined) {
            console.log("Price: " + orders[id_iter_ask].price + " | Volume: " + orders[id_iter_ask].volume + " | Owner: " + orders[id_iter_ask].owner);
            id_iter_ask = ask_orderbook[id_iter_ask].next_id;
        }
    }


    // var matchedAskOrders = new Hashtable(); // wird niemals gelöscht
    // var matchedBidOrders = new Hashtable(); // wird niemals gelöscht



    var period = 0;

    var tmpMatchedBid = {};
    var tmpMatchedAsk = {};

    var matchedAskOrders = {};

    var askmapping = {};
    var bidmapping = {};

    // ich muss die matched orders erst nach owner dann nach periode abspeichern
    function determine_matching_price() {
        var cumAskVol = 0;
        var cumBidVol = 0;
        var matching_price;

        matching_price = orders[lowest_ask_id].price;
        var isMatched = false;
        var bid_price = orders[highest_bid_id].price;
        var id_iter_ask = lowest_ask_id;
        var id_iter_bid = highest_bid_id;
        period++;


        while (!isMatched) {
            while (orders[id_iter_ask].price == matching_price) {
                var volume = orders[id_iter_ask].volume;
                var owner = orders[id_iter_ask].owner;
                var next = ask_orderbook[id_iter_ask].next_id;

                cumAskVol += volume;


                appendToDoubleMapping(askmapping, period, owner, {
                    orderedVolume: volume
                });


                id_iter_ask = next;

                if (id_iter_ask == undefined) {
                    break;
                }
            }

            while (orders[id_iter_bid].price >= matching_price) { // TODO: die bid preise gehe ich jedes Mal von vorne durch. effizienter macehn
                var volume = orders[id_iter_bid].volume;
                var owner = orders[id_iter_bid].owner;
                var next = bid_orderbook[id_iter_bid].next_id;

                cumBidVol += volume;

                appendToDoubleMapping(bidmapping, period, owner, {
                    orderedVolume: volume
                });

                id_iter_bid = next;

                if (id_iter_bid == undefined) {
                    break;
                }
            }
            if (cumAskVol >= cumBidVol) {
                isMatched = true;
            } else {
                matching_price = orders[id_iter_ask].price;
                id_iter_bid = highest_bid_id;
                cumBidVol = 0;
                delete tmpMatchedBid;
            }
        }

        var share = cumBidVol / cumAskVol;

        console.log("Price: " + matching_price + " | cumBidVol: " + cumBidVol + " | cumAskVol: " + cumAskVol + " and share: " + share);


        for (owner in askmapping[period]) {
            askmapping[period][owner].orderedVolume = askmapping[period][owner].orderedVolume * share;
        }




        // for (owner in tmpMatchedAsk) {
        //     var x = parseInt(owner);
        //     var ht = new Hashtable();
        //     var matchData = {
        //         orderedVolume: tmpMatchedAsk[owner] * share
        //     }

        //     matchedAskOrders.put(x, ht);
        //     matchedAskOrders.get(x).put(period, matchData);
        // }

        // for (owner in tmpMatchedBid) {
        //     var x = parseInt(owner);
        //     var ht = new Hashtable();
        //     var matchData = {
        //         orderedVolume: tmpMatchedBid[owner]
        //     }

        //     matchedBidOrders.put(x, ht);
        //     matchedBidOrders.get(x).put(period, matchData);
        // }


        lowest_ask_id = undefined;
        highest_bid_id = undefined;
        orders = {}; // nach dem matching müssen alle übrig gebliebenen orders gelöscht werden.
    }


    function createMapping(_key, _value) {
        var mapping = {};
        mapping[_key] = _value;

    }

    function createDoubleMapping(_key1, _key2, _value) {
        var mapping = {};
        var mapping2 = {};

        mapping2[_key2] = _value;
        mapping[_key1] = mapping2;

        return mapping;
    }

    function appendToDoubleMapping(_mapping, _key1, _key2, _value) {
        if (_mapping[_key1] == undefined) {
            var mapping2 = {};
            mapping2[_key2] = _value;
            _mapping[_key1] = mapping2;
        } else {
            _mapping[_key1][_key2] = _value;
        }
    }



    var MIN_RESERVE_VOLUME = 1000;
    var matchedReserveOrders = new Hashtable();
    var tmpmatchedReserveOrders = {}; // wird niemals gelöscht 
    var reservemapping = {};

    function determineReservePrice() {
        var cumAskReserveVol = 0;
        var reserve_price;
        var isFound = false;
        reserve_price = orders[lowest_ask_id].price;
        var id_iter_ask = lowest_ask_id;

        while (!isFound) {
            while (orders[id_iter_ask].price == reserve_price) {
                var volume = orders[id_iter_ask].volume;
                var owner = orders[id_iter_ask].owner;
                var next = ask_orderbook[id_iter_ask].next_id;

                cumAskReserveVol += volume;
                appendToDoubleMapping(reservemapping, period, owner, {
                    orderedVolume: volume
                });
                id_iter_ask = next;

                if (id_iter_ask == undefined) {
                    break;
                }
            }

            if (cumAskReserveVol >= MIN_RESERVE_VOLUME) {
                isFound = true;
            } else {
                reserve_price = orders[id_iter_ask].price;
            }
        }
        orders = {};

        for (owner in askmapping[period]) {

            askmapping[period][owner].reservePrice = reserve_price;

        }

        for (owner in bidmapping[period]) {

            bidmapping[period][owner].reservePrice = reserve_price;

        }
        owner_address = 0;





        // for (owner in tmpmatchedReserveOrders) {
        //     var x = parseInt(owner);
        //     var ht = new Hashtable();
        //     var matchData = {
        //         orderedVolume: tmpmatchedReserveOrders[owner]
        //     }

        //     matchedReserveOrders.put(x, ht);
        //     matchedReserveOrders.get(x).put(period, matchData);
        // }

        // TODO: den preis im doppelten mapping niederschreiben 



        // matchedAskOrders.each(function(key, value) {

        //     if (value.get(period) != null) {
        //         var orderedVolume = value.get(period).orderedVolume;
        //         var matchData = {
        //             orderedVolume: value.get(period).orderedVolume,
        //             reservePrice: reserve_price
        //         };

        //         var orderedVolume = value.put(period, matchData);

        //     }


        // })

        // matchedBidOrders.each(function(key, value) {

        //     if (value.get(period) != null) {
        //         var orderedVolume = value.get(period).orderedVolume;
        //         var matchData = {
        //             orderedVolume: value.get(period).orderedVolume,
        //             reservePrice: reserve_price
        //         };

        //         var orderedVolume = value.put(period, matchData);

        //     }
        // })


        // for (owner in matchedAskOrders) { // nur die matched bid orders brauchen den reserve price.
        //     if (matchedAskOrders[owner].reserve_price == undefined) {
        //         matchedAskOrders[owner].reserve_price = reserve_price;
        //     }
        // }

    }

    // function test_getAskOrders() {
    //     matchedAskOrders.each(function(key, value) {

    //         console.log("Owner: " + key);

    //         value.each(function(period, matchData) {
    //             console.log("Period " + period + ":  OrderedVolume=" + matchData.orderedVolume + " | reservePrice= " + matchData.reservePrice);
    //         });

    //     });
    // }

    function getOrders() {

        console.log("######################################");
        console.log("Matched Ask Orders");
        console.log("######################################");

        for (period in askmapping) {
            console.log("\n");
            for (owner in askmapping[period]) {
                console.log("Period: ", period," | Owner: ", owner, " | OrderedVol: ", askmapping[period][owner].orderedVolume, " | ReservePrice: ", askmapping[period][owner].reservePrice)
            }
        }


        console.log("######################################");
        console.log("Matched Bid Orders");
        console.log("######################################");

        for (period in bidmapping) {
            console.log("\n");
            for (owner in bidmapping[period]) {
                console.log("Period: ", period," | Owner: ", owner, " | OrderedVol: ", bidmapping[period][owner].orderedVolume, " | ReservePrice: ", bidmapping[period][owner].reservePrice)
            }
        }
    }



    function settleUserPosition(_user, _type, _volume, _period) {
        var user = _user;
        var ordered;
        var offered;
        var diff;
        var reservePrice;

        if (_type == "CONSUMER" && bidmapping[_period][user] != undefined && bidmapping[_period] != undefined) {
            ordered = bidmapping[_period][user].orderedVolume;
            reservePrice = bidmapping[_period][user].reservePrice;
            if (ordered < _volume) {
                diff = _volume - ordered;
                colleteral[user] -= (diff * reservePrice);
            }
            bidmapping[_period][user] = {};
        }

        if (_type == "PRODUCER" && askmapping[_period][user] != undefined && askmapping[_period] != undefined) {
            offered = askmapping[_period][user].orderedVolume;
            reservePrice = askmapping[_period][user].reservePrice;
            if (offered > _volume) {
                diff = offered - _volume;
                colleteral[user] -= (diff * reservePrice);
            }
            askmapping[_period][user] = {};
        }
    
    }


    function test_submit() {
        submitAskOrder(20, 25);
        submitAskOrder(23, 45);
        submitAskOrder(24, 1);
        submitAskOrder(30, 40);
        submitAskOrder(30, 50);
        submitBidOrder(999, 67);
        submitBidOrder(10, 200);
        submitBidOrder(30, 10);
        getBidOrders();
        getAskOrders();
    }

    function test_submitReserve() {
        submitAskOrder(20, 100);
        submitAskOrder(23, 100);
        submitAskOrder(24, 700);
        submitAskOrder(30, 800);
        submitAskOrder(30, 500);
        getAskOrders();
    }

    function test() {
        test_submit();
        determine_matching_price();
        test_submitReserve();
        determineReservePrice();
    }
    </script>
</body>

</html>
